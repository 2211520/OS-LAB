# 操作系统实验二：物理内存管理与页表映射简化报告
## 一、基本练习报告内容
### 1.1 物理内存探测与初始化
- **探测方式**：通过OpenSBI的DTB（Device Tree Blob）获取物理内存信息，DTB地址由`a1`寄存器传入，解析得到基地址（默认`0x80000000`）、大小（默认128MiB），可用范围为`[KernelEnd, 0x88000000)`（排除内核与OpenSBI占用区）。
- **初始化流程**：
  1. `page_init()`：初始化`Page`数组，标记内核占用页为`PG_reserved`（不可分配）。
  2. `init_memmap()`：将可用内存初始化为空闲块，设置页帧状态并加入空闲链表。
  3. `pmm_init()`：初始化内存管理器，调用探测与初始化函数，执行分配测试。

### 1.2 核心数据结构
- **Page结构体**：描述单个页帧，含引用计数（`ref`）、状态标志（`flags`，如`PG_reserved`/`PG_property`）、空闲块大小（`property`，仅首页有效）、空闲链表节点（`page_link`）。
- **free_area_t结构体**：管理空闲块，含空闲链表头（`free_list`）、空闲页总数（`nr_free`）。

### 1.3 练习1：First-Fit连续内存分配算法
- **算法原理**：从空闲链表头部遍历，找到第一个满足需求的空闲块分配，优先用低地址内存。
- **核心函数**：
  1. `default_init()`：初始化空闲链表（`free_list`）与空闲页计数（`nr_free=0`）。
  2. `default_init_memmap(base, n)`：初始化`base`开始的`n`个页帧，标记首页`PG_property`，按地址升序加入空闲链表，更新`nr_free`。
  3. `default_alloc_pages(n)`：遍历空闲链表找首个满足大小的块，拆分剩余部分回链表，更新`nr_free`与页帧状态。
  4. `default_free_pages(base, n)`：重置释放页帧状态，按地址插入空闲链表，合并前后相邻空闲块，更新`nr_free`。
- **改进空间**：
  - 优化查找：按块大小分段维护链表，或用平衡树/哈希表降时间复杂度。
  - 减少碎片：引入延迟合并（碎片超阈值整理）或结合伙伴系统。
  - 并发适配：加自旋锁（如`spinlock_t`）确保链表操作原子性。

### ### 1.4 练习2：Best-Fit连续内存分配算法
#### 1.4.1 算法核心原理与设计目标
- **核心定义**：Best-Fit（最佳适应）算法是动态分区分配策略的经典实现，其核心逻辑是**遍历所有空闲分区，筛选出大小能满足需求且最小的空闲块进行分配**。该算法的设计目标是尽可能保留大块空闲内存，为后续可能出现的大内存需求预留空间，从而在理论上降低“大块内存被拆分殆尽”的风险。
- **与First-Fit的本质差异**：
  - First-Fit以“查找效率”为优先，仅遍历至首个满足条件的块即停止，无需扫描全链表；
  - Best-Fit以“内存利用率”为优先，必须完整遍历空闲链表以确定“最优”块，因此分配阶段的时间复杂度更高（均为O(n)，但实际执行路径更长）。

#### 1.4.2 关键实现逻辑（基于实验框架）
Best-Fit算法的初始化、内存映射、释放逻辑与First-Fit完全复用，核心差异仅体现在`best_fit_alloc_pages(n)`函数的实现，具体流程如下：

1.  **函数入口与参数校验**：
    - 输入参数`n`为需分配的页帧数量，首先校验`n`的合法性（需大于0且不超过总空闲页`nr_free`），若不合法直接返回`NULL`。

2.  **最优空闲块查找**：
    ```c
    struct Page *page = NULL;
    size_t min_size = nr_free + 1;  // 初始化最小满足大小为超界值
    struct Page *p, *prev = NULL;
    
    // 遍历整个空闲链表，筛选最优块
    list_for_each_entry(p, &free_list, page_link) {
        if (p->property >= n && p->property < min_size) {
            min_size = p->property;  // 更新当前最小满足大小
            page = p;                // 标记当前最优块
        }
    }
    ```
    - 遍历过程中，通过`min_size`记录已发现的“满足需求的最小块大小”，并通过`page`指针锁定对应块；
    - 由于需比较所有块的大小，**必须完整遍历链表**，无法像First-Fit那样提前终止，这是其性能开销的核心来源。

3.  **空闲块拆分与状态更新**：
    - 若找到最优块（`page != NULL`），首先标记该块的`PG_property`标志位为0（表示不再是空闲块首页）；
    - 若分配后存在剩余空间（`page->property > n`），则从剩余空间的起始页帧开始初始化新空闲块：设置该页的`PG_property=1`，`property=page->property - n`，并按地址升序插入空闲链表；
    - 若分配后无剩余空间（`page->property == n`），直接将该块从空闲链表中移除；
    - 最后更新空闲页总数`nr_free -= n`，返回分配的页帧首地址。

4.  **内存释放逻辑（复用与适配）**：
    - 释放函数`default_free_pages(base, n)`与First-Fit完全一致，核心步骤包括：重置释放页帧的状态标志、按物理地址升序插入空闲链表、合并前后相邻的空闲块（避免外部碎片）、更新`nr_free`计数；
    - 需特别注意：释放后必须按地址排序链表，而非按块大小排序，这是因为内存合并依赖地址连续性，与Best-Fit分配时的“按大小筛选”逻辑不冲突。

#### 1.4.3 实验验证与现象分析
1.  **功能验证步骤**：
    - 修改实验配置：在内存管理器初始化处指定`best_fit_pmm_manager`，替代默认的First-Fit管理器；
    - 编译与运行：执行make grade，根据输出的分数判断是否成功
2.  **典型测试场景与结果**：
    - 场景1：初始空闲块为[0x80200000, 0x80300000)（共64个页帧），依次分配10、20、5个页帧；
      - Best-Fit分配路径：首次分配10页时选择64页块，拆分后剩余54页；二次分配20页时选择54页块，拆分后剩余34页；三次分配5页时选择34页块，拆分后剩余29页；
      - 核心特征：始终选择当前最小的可用块，避免拆分更大的块（若存在多个空闲块）。
    - 场景2：空闲链表存在[10页, 15页, 20页]三个块，申请12页内存；
      - Best-Fit会选择15页块（而非20页块），拆分后剩余3页，保留了更大的20页块供后续使用。

#### 1.4.4 是否有更改空间
| 优点                          | 缺点                          |
|-------------------------------|-------------------------------|
| 优先分配小空闲块，最大限度保留大块内存，适配未来大内存需求 | 必须遍历全链表，分配效率低于First-Fit，频繁分配时开销明显 |
| 单次分配产生的剩余空间最小，理论上可减少“大块拆分导致的外部碎片” | 易产生大量难以利用的小空闲块（如分配10页后剩余3页），长期使用可能增加碎片率 |
| 释放时的合并逻辑与First-Fit通用，实现成本低 | 若空闲链表无序，每次分配前需额外排序（实验中未实现，需手动优化），进一步增加开销 |

### 1.5 页表与分页机制（RISCV sv39）
- **地址结构**：
  - 虚拟地址（VA）：39位，分27位VPN（虚拟页号）+12位页内偏移。
  - 物理地址（PA）：56位，分44位PPN（物理页号）+12位页内偏移。
  - 页大小：4KB，页内偏移VA与PA一致。
- **三级页表**：将27位VPN拆为3个9位段（VPN[2]/VPN[1]/VPN[0]），一级页表管512个1GiB块、二级管512个2MiB块、三级管512个4KB块，页表项指向下级页表或物理页帧。
- **关键硬件**：
  - TLB（快表）：缓存VPN-PPN映射，减少内存访问。
  - satp寄存器：存页表根节点PPN与模式（sv39为`8<<60`），修改后需`sync.vma`刷新TLB。


## 二、实验重要知识点与OS原理对应关系
| 实验知识点                | OS原理知识点                | 理解（含义、关系、差异）                                                                 |
|---------------------------|-----------------------------|------------------------------------------------------------------------------------------|
| DTB物理内存探测与初始化   | 物理内存探测与管理初始化    | 实验是原理的具体实现：原理指OS启动时需探测硬件内存布局，实验通过解析DTB获取内存参数，流程完全对应，无差异。 |
| Page/free_area_t结构体    | 页帧描述符与空闲块管理      | 原理提出用数据结构描述页帧与空闲块，实验用Page结构体记录页帧状态、free_area_t管理空闲链表，是原理的落地，结构设计与原理一致。 |
| First-Fit/Best-Fit算法    | 连续物理内存分配算法        | 原理定义两种经典算法：First-Fit找首个满足块、Best-Fit找最小满足块；实验实现了这两种算法，逻辑与原理完全匹配，无差异，仅实验需处理具体链表操作。 |
| 三级页表（sv39）          | 多级页表机制                | 原理为解决一级页表内存占用过大，提出拆分页号分级管理；实验的sv39三级页表是原理的实例，27位VPN拆3个9位段，与原理“分级降内存开销”的核心思想一致。 |
| satp寄存器与TLB刷新       | 硬件辅助地址转换            | 原理指出需硬件寄存器存页表根地址、TLB缓存映射；实验中satp存页表根PPN与模式，TLB需`sync.vma`刷新，完全符合原理的硬件支持逻辑。 |


## 三、OS原理重要但实验未覆盖的知识点
1. **页面置换算法**：原理中内存不足时需用LRU、Clock等算法置换页面（虚拟内存“换页”），实验仅实现内存分配，未涉及置换。
2. **内存共享与Copy-on-Write**：原理支持多进程共享物理页帧，并用“写时复制”优化内存使用，实验未涉及进程共享与该优化。
3. **大页（2MiB/1GiB）使用**：原理中用大页减少TLB失效提升效率，实验仅使用4KB普通页，未实现大页功能。
